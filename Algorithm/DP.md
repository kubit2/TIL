# DP(Dynamic Programming)

- 하나의 큰 문제를 여러 개의 작은 문제로 나누어서 그 결과를 저장하여 다시 큰 문제를 해결할 때 사용
- 알고리즘이라기 보단 **하나의 문제 해결 패러다임**
- **큰 문제를 작은 문제로 쪼개서 그 답을 저장해두고 재활용한다!**

## 🤷🏻 DP를 왜 사용할까?

일반적인 재귀 방식 또한 DP와 매우 유사하나,

- 일반적인 재귀를 단순히 사용하면?

  → **동일한 작은 문제들이 여러 번 반복되어 비효율적인 계산을 하게 될 수 있다!**

- 만약, DP를 사용해 한 번 구한 작은 문제의 결과 값을 저장해두고 재사용할 수 있다면?
  → **앞에서 계산된 값을 다시 반복할 필요없이 계산이 가능해진다!**

## 📌 DP 사용 조건

- **Overlapping Subproblems** (겹치는 부분 문제)

  DP는 기본적으로 문제를 나누고 그 문제의 결과 값을 재활용해서 전체 답을 구하기 때문에,

  동일한 작은 문제들이 반복하여 나타나는 경우에 사용이 가능!

  `즉, DP는 부분 문제의 결과를 저장하여 재계산하지 않을 수 있어야 하는데, 
해당 부분 문제가 반복적으로 나타나지 않는다면 재사용이 불가능하니 부분 문제가 중복되지 않는 경우에는 사용할 수 없다.`

- **Optimal Substructure** (최적 부분 구조)
  부분 문제의 최적 결과 값을 사용해 전체 문제의 최적 결과를 낼 수 있는 경우를 의미
  `특정 문제의 정답은 문제의 크기에 상관없이 항상 동일!`

## ✳️ DP 사용하기

> 1. DP로 풀 수 있는 문제인지 확인하기
> 2. 문제의 변수 파악하기
> 3. 변수 간 관계식 만들기
> 4. 메모하기
> 5. 기저 상태 파악하기
> 6. 구현하기

### **1. DP로 풀 수 있는 문제인지 확인하기**

`⭐️ 현재 직면한 문제가 작은 문제들로 이루어진 하나의 함수로 표현될 수 있는지를 판단하는 게 중요 ⭐️`

→ DP 사용 조건들에 충족되는 문제인지 체크해보자!

보통 특정 데이터 내 최대화/최소화 계산을 하거나 특정 조건 내 데이터를 세야 한다거나 확률 등의 계산의 경우에 DP로 풀 수 있는 경우가 많다!

### 2. 문제의 변수 파악하기

DP는 현재 변수에 따라 그 결과 값을 찾고 그것을 전달하여 재사용하는 것을 거친다.

**즉, 문제 내 변수의 개수를 알아내야 한다는 것 → “state 결정”**

### 3. 변수 간 관계식 만들기 (점화식)

변수들에 의해 결과 값이 달라지지만 동일한 변수값인 경우 결과는 동일하다.

또한, 우리는 그 결과값을 그대로 이용할 것이므로 그 관계식을 만들어낼 수 있어야 한다.

⇒ `점화식을 만들어서 짧은 코드 내에 반복/재귀를 통해 문제가 자동으로 해결되도록 구축하기!`

ex) 피보나치 수열: f(n) = f(n-1) + f(n-2)

### 4. 메모하기 (Memoization)

메모하기? → 변수의 값에 따른 결과 저장하기!

변수 값에 따른 결과를 저장할 배열 등을 미리 만들고, 결과가 나올 때마다 배열 내에 저장하고,

그 저장된 값을 재사용하는 방식으로 문제를 해결해 나간다.

이 결과 값을 저장할 때는 보통 배열을 쓰며 변수의 개수에 따라 배열의 차원이 1~3차원 등 다양할 수 있다.

### 5. 기저 상태 파악하기

가장 작은 문제의 상태를 알아야 한다.

### 6. 구현하기

- **Bottom-Up (Tabulation 방식)** - 반복문 사용
  **아래에서부터 계산을 수행하고, 누적시켜서 전체 큰 문제를 해결하는 방식**
  메모를 위해서 dp라는 배열을 만들었고 이것이 1차원이라 가정했을 때, dp[0]가 기저 상태이고 dp[n]을 목표상태라고 하자. Bottom-up은 dp[0]부터 시작하여 반복문을 통해 점화식으로 결과를 내서 dp[n]까지 그 값을 전이시켜 재활용하는 방식이다.
  **왜 Tabulation?**
  반복을 통해 dp[0]부터 하나 하나씩 채우는 과정을 “table-filling”이라고 하며, 이 Table에 저장된 값에 직접 접근하여 재활용하기 때문이다.
- **Top-Down (Memoization 방식)** - 재귀 사용
  dp[0]의 기저 상태에서 출발하는 대신 dp[n]의 값을 찾기 위해 **위에서 부터 바로 호출을 시작**하여, dp[0]의 상태까지 내려간 다음 해당 **결과 값을 재귀를 통해 전이시켜 재활용하는 방식**
